---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by likai.
--- DateTime: 2021/5/13 3:01 PM
--- 开心点

Happy = {}
local HappyFuns = HappyCode.HappyFuns

local matCaches = {}
---处理对象下面所有指定type的材质球
function Happy.DoWithMaterials(gameObj, fun, type)
    type = type or UnityEngine.Renderer
    local mList
    if not matCaches[gameObj] then
        mList = {}

        local smList = gameObj:GetComponentsInChildren(typeof(type))
        for i = 0, smList.Length-1 do
            local sm = smList[i] ---@type UnityEngine.Renderer
            for j = 0, sm.materials.Length-1 do
                local m = sm.materials[j] ---@type UnityEngine.Material
                table.insert(mList, m)
            end
        end
    else
        mList = matCaches[gameObj]
    end
    for i = 1, #mList do
        fun(mList[i])
    end
end

---取得数组中的随机项
function Happy.GetRandomInTable(tab, remove)
    local randomIndex = math.round(Happy.Random(1, #tab))
    if remove == true then
        return table.remove(tab, randomIndex)
    else
        return tab[randomIndex]
    end

end

---浮点数缓动
---@return DG.Tweening.Core.TweenerCore
function Happy.DOTweenFloat(startValue, endValue, duration, setFloatFun, callBack, ease)
    local value = startValue
    local function getFunc()
        return value
    end
    local function setFunc(floatValue)
        setFloatFun(floatValue)
        value = floatValue
    end
    local getter = DG.Tweening.Core.DOGetter_float(getFunc)
    local setter = DG.Tweening.Core.DOSetter_float(setFunc)
    ease = ease or DOTWEEN_EASE.Linear
    local DOTween = DG.Tweening.DOTween ---@type DG.Tweening.DOTween
    return DOTween.To(getter, setter, endValue, duration):SetEase(ease):OnComplete(function ()
        if callBack then
            callBack(value)
        end
    end)
end

---主相机模糊开关
---@param enabled boolean
---@param dynamic boolean 是否动态每帧都截图
---@param range number 模糊强度
function Happy.MainCameraBlurToggle(enabled, range)
    do return end
    range = range or 2
    if not Happy.blurImg then
        local obj = GameObject.New() ---@type UnityEngine.GameObject
        obj.name = "blurScreen"
        obj.transform:SetParent(UIMgr.GetLayer(UILayerName.scene))
        obj.transform:SetAsFirstSibling()
        obj.layer = LayerMask.NameToLayer("UI")
        local rect = AddOrGetComponent(obj, UnityEngine.RectTransform) ---@type UnityEngine.RectTransform
        rect.anchorMin = Vector2.zero
        rect.anchorMax = Vector2.one
        rect.offsetMax = Vector2.zero
        rect.offsetMin = Vector2.zero
        rect.anchoredPosition3D = Vector3.zero
        rect.localScale = Vector3.one
        rect.localEulerAngles = Vector3.zero

        Happy.blurImg = AddOrGetComponent(obj, UnityEngine.UI.RawImage) ---@type UnityEngine.UI.RawImage

        Happy.blurImg.texture = UnityEngine.Resources.Load("RenderTexture/blurTex")
    end
    LuaHelper.DrawBlurTextureToggle(enabled, range)
    Happy.blurImg.gameObject:SetActive(enabled)
    return Happy.blurImg
end

Happy.btnEffObjs = {}
---带默认效果的点击交互
---@param gameObj UnityEngine.GameObject
function Happy.BtnClickDownUP(gameObj, UpCallback, DownCallback, noEff, setScale)
    Happy.ClearBtnClick(gameObj)
    local initScale = gameObj.transform.localScale
    local isDown = false
    local DownL = function()
        if not noEff then
            gameObj.transform:DOScale(initScale * (setScale or 1.1), 0.05)
        end
        isDown = true
        if DownCallback then
            DownCallback()
        end
    end
    local downHandler = AddButtonHandler(gameObj, PointerHandler.DOWN, DownL)
    local UpL = function()
        if not noEff then
            gameObj.transform:DOScale(initScale, 0.05)
        end
        isDown = false
        if UpCallback then
            UpCallback()
        end
    end
    local clickHandler = AddButtonHandler(gameObj, PointerHandler.CLICK, UpL)
    local ExitL = function()
        if not noEff and isDown == true then
            gameObj.transform:DOScale(initScale, 0.05)
        end
    end
    local exitHandler = AddButtonHandler(gameObj, PointerHandler.EXIT, ExitL)
    local upHandler = AddButtonHandler(gameObj, PointerHandler.UP, ExitL)

    local DestryL = function()
        Happy.ClearBtnClick(gameObj)
    end
    local destroyHandler = AddEventListener(gameObj, Event.ON_DESTROY, DestryL)

    Happy.btnEffObjs[gameObj] = {downHandler, clickHandler, exitHandler, upHandler, destroyHandler}
end

---清除点击交互
---@param gameObj UnityEngine.GameObject
function Happy.ClearBtnClick(gameObj)
    if not Happy.btnEffObjs[gameObj] then
        return
    end
    local downHandler = Happy.btnEffObjs[gameObj][1]
    local clickHandler = Happy.btnEffObjs[gameObj][2]
    local exitHandler = Happy.btnEffObjs[gameObj][3]
    local upHandler = Happy.btnEffObjs[gameObj][4]
    local destroyHandler = Happy.btnEffObjs[gameObj][4]
    RemoveButtonHandler(gameObj, PointerHandler.DOWN, downHandler)
    RemoveButtonHandler(gameObj, PointerHandler.CLICK, clickHandler)
    RemoveButtonHandler(gameObj, PointerHandler.EXIT, exitHandler)
    RemoveButtonHandler(gameObj, PointerHandler.UP, upHandler)
    RemoveEventListener(gameObj, Event.ON_DESTROY, destroyHandler)
end

Happy.btnEffObjs3D = {}
---带默认效果的点击交互
---@param gameObj UnityEngine.GameObject
function Happy.BtnClickDownUP3D(gameObj, UpCallback, DownCallback, noEff, setScale)
    Happy.ClearBtnClick3D(gameObj)
    local initScale = gameObj.transform.localScale
    local isDown = false
    local DownL = function()
        if not noEff then
            gameObj.transform:DOScale(initScale * (setScale or 1.1), 0.05)
        end
        isDown = true
        if DownCallback then
            DownCallback()
        end
    end
    local downHandler = AddButtonHandler3D(gameObj, PointerHandler.DOWN, DownL)
    local UpL = function()
        if not noEff then
            gameObj.transform:DOScale(initScale, 0.05)
        end
        isDown = false
        if UpCallback then
            UpCallback()
        end
    end
    local clickHandler = AddButtonHandler3D(gameObj, PointerHandler.CLICK, UpL)
    local ExitL = function()
        if not noEff and isDown == true then
            gameObj.transform:DOScale(initScale, 0.05)
        end
    end
    local exitHandler = AddButtonHandler3D(gameObj, PointerHandler.EXIT, ExitL)
    local upHandler = AddButtonHandler3D(gameObj, PointerHandler.UP, ExitL)

    local DestryL = function()
        Happy.ClearBtnClick(gameObj)
    end
    local destroyHandler = AddButtonHandler3D(gameObj, Event.ON_DESTROY, DestryL)

    Happy.btnEffObjs3D[gameObj] = {downHandler, clickHandler, exitHandler, upHandler, destroyHandler}
end

---清除点击交互
---@param gameObj UnityEngine.GameObject
function Happy.ClearBtnClick3D(gameObj)
    if not Happy.btnEffObjs3D[gameObj] then
        return
    end
    local downHandler = Happy.btnEffObjs3D[gameObj][1]
    local clickHandler = Happy.btnEffObjs3D[gameObj][2]
    local exitHandler = Happy.btnEffObjs3D[gameObj][3]
    local upHandler = Happy.btnEffObjs3D[gameObj][4]
    local destroyHandler = Happy.btnEffObjs3D[gameObj][4]
    RemoveButtonHandler3D(gameObj, PointerHandler.DOWN, downHandler)
    RemoveButtonHandler3D(gameObj, PointerHandler.CLICK, clickHandler)
    RemoveButtonHandler3D(gameObj, PointerHandler.EXIT, exitHandler)
    RemoveButtonHandler3D(gameObj, PointerHandler.UP, upHandler)
    RemoveButtonHandler3D(gameObj, Event.ON_DESTROY, destroyHandler)
end

---获取UI灰色材质球
---@return UnityEngine.Material
function Happy.GetGrayMat()
    return resMgr:LoadMaterialAtPath("Materials/UI/gray2D.mat")
end

---SetLayerRecursive
---@param o UnityEngine.GameObject
---@param layer number
function Happy.SetLayerRecursive(o, layer)
    HappyFuns.SetLayerRecursive(o, layer)
end

---UI变灰
---type 0Image Text都起效  1Image  2Text
function Happy.ChangeUIGray(gameObject, gray, withChildren, tweenFromValue, tweenToValue, tweenDur)
    --logWarning("======  "..gameObject.name.."   "..tostring(gray))
    local setMat = gray and Happy.GetGrayMat() or nil ---@type UnityEngine.Material
    if gray == true and not tweenToValue then
        setMat:SetFloat("_GrayEnable", 1)
    end
    if GetComponent.Image(gameObject) then
        GetComponent.Image(gameObject).material = setMat
    end
    if GetComponent.Text(gameObject) then
        GetComponent.Text(gameObject).material = setMat
    end
    if tweenFromValue and tweenToValue then
        Happy.DOTweenFloat(tweenFromValue, tweenToValue, tweenDur or 0.5, function(value)
            setMat:SetFloat("_GrayEnable", value)
        end)
    end

    if withChildren == true then
        local tran = gameObject.transform
        for i = 1, tran.childCount do
            Happy.ChangeUIGray(tran:GetChild(i-1).gameObject, gray, withChildren, tweenToValue)
        end
    end
end


local objs = {}
local shakeHandler
shakeHandler = function()
    local empty = true
    local disabledObjs = {}
    local endObjs = {}
    for obj, info in pairs(objs) do
        local endCheck = false
        if info.duration > 0 then
            endCheck = (Time.time - info.startTime) > info.duration
        end
        if isnull(obj) == true then
            table.insert(disabledObjs, obj)
        elseif endCheck == true then
            table.insert(endObjs, obj)
        else
            empty = false
            info.shakeFun(info)
        end
    end
    --print("你妹啊 shakeHandler", empty, #endObjs)

    for i = 1, #disabledObjs do
        Happy.StopShake(disabledObjs[i])
    end
    for i = 1, #endObjs do
        local info = Happy.StopShake(endObjs[i])
        if info.callBack then
            info.callBack()
        end
    end
    if empty == true then
        RemoveEventListener(Stage, Event.LATE_UPDATE, shakeHandler)
    end
end

---震动 默认震动主相机
---@param obj UnityEngine.GameObject
---@param duration number -1就会不停
function Happy.Shake(obj, duration, callBack, range, isCamera)
    duration = duration or 0.5

    range = range or 1
    if isCamera == true then
        range = range / 20
    end

    if not obj then
        return
    end

    local startTime = Time.time
    if objs[obj] then
        Happy.StopShake(obj)
    end

    local doShake = function(info)
        local tran = info.tran
        tran.position = tran.position - info.sv
        --print("哦呵呵呵", cameraT.position.x, cameraT.position.y, cameraT.position.z)
        info.sv = Vector3.New(info.range * math.random(0, 1),
                info.range * math.random(0, 1),
                info.range * math.random(0, 1))

        --print("你妹啊 doShake", sv.x, sv.y, sv.z)
        tran.position = tran.position + info.sv
    end

    objs[obj] = {tran = obj.transform, orgPos=obj.transform.position, range = range, duration = duration, startTime = startTime,
                 callBack = callBack, sv = Vector3.zero, shakeFun = doShake}
    AddEventListener(Stage, Event.LATE_UPDATE, shakeHandler)
end

---@param obj UnityEngine.GameObject
function Happy.StopShake(obj)
    if not obj then
        obj = Camera.main.gameObject
    end

    if not obj then
        return nil
    end
    local info = objs[obj]
    objs[obj] = nil
    if info and isnull(info.tran) ~= true then
        info.tran.position = info.tran.position - info.sv
    end
    return info
end


---名字路径找对象 支持active = false 无递归
function Happy.FindGameObject(name)
    local rootName = name
    if not string.find(name, "/") then
        local list = HappyFuns.FindRootObj(rootName)
        if list.Length > 0 then
            return list[0]
        else
            return nil
        end
    end
    rootName = string.sub(name, 1, string.find(name, "/") - 1)
    local otherName = string.sub(name, string.find(name, "/") + 1, string.len(name))
    local rootObj = nil
    if HappyFuns.FindRootObj(rootName).Length > 0 then
        rootObj = HappyFuns.FindRootObj(rootName)[0]
    else
        return nil
    end

    if not rootObj or isnull(rootObj) then
        return nil
    end

    local childT = rootObj.transform:Find(otherName)
    if not childT or isnull(childT) then
        return nil
    end
    return childT.gameObject
end

---从父级 递归找对象
---@param parent UnityEngine.Transform
---@return UnityEngine.Transform
function Happy.FindGameObjectLoopFromParent(name, parent)
    local childCount = parent.childCount
    local goal
    for i = 0, childCount-1 do
        local child = parent:GetChild(i)
        if child.name == name then
            goal = child
        else
            goal = Happy.FindGameObjectLoopFromParent(name, child)
        end

        if goal then
            return goal
        end
    end
end

---变色屏过渡
---@return UnityEngine.GameObject
function Happy.ScreenTrans(endCall, waitDur, color, toMiddleParams, toEndParams, textParams, layerName)
    toMiddleParams = toMiddleParams or {}
    toEndParams = toEndParams or {}
    textParams = textParams or {}
    waitDur = waitDur or 1

    color = color or Color.black
    local obj = CreatePrefab("Prefabs/Common/ScreenTrans.prefab", layerName or Constants.LAYER_GUIDE)

    local rect = GetComponent.RectTransform(obj)
    rect.localScale = Vector3.one
    rect.offsetMax = Vector2.one * 10
    rect.offsetMin = Vector2.one * -10
    local img = GetComponent.Image(obj)
    local label = GetComponent.TextMeshProUGUI(obj.transform:Find("Text").gameObject)
    local cg = GetComponent.CanvasGroup(obj)

    img.color = color
    cg.alpha = 0
    local seq = DOTween.Sequence()
    seq:Append(cg:DOFade(toMiddleParams.alpha or 1, toMiddleParams.dur or 1):SetEase(DOTWEEN_EASE.Linear))
    label.text = ""
    if textParams.content then
        seq:Append(label:DOText(textParams.content, string.len(textParams.content) * 0.05 / (textParams.speed or 1)):SetEase(DOTWEEN_EASE.Linear))
    end
    if toMiddleParams.callBack then
        seq:AppendCallback(toMiddleParams.callBack)
    end
    seq:AppendInterval(waitDur)
    seq:Append(cg:DOFade(toEndParams.alpha or 0, toEndParams.dur or 1):SetEase(DOTWEEN_EASE.Linear))
    seq:AppendCallback(function ()
        RecyclePrefab(obj,"Prefabs/Common/ScreenTrans.prefab")
        if endCall then
            endCall()
        end
    end)

    return obj
end

local loopFuns = {}
---注册一个时间循环播放函数
function Happy.RegisterLoopFun(obj, func, gapTime, limitTimes, getGapTimeFun, noFirstRun, log)
    gapTime = gapTime or 1
    Happy.UnRegisterLoopFun(obj, log)
    loopFuns[obj] = {func=func, gapTime=gapTime, getGapTimeFun = getGapTimeFun, limitTimes = limitTimes, curTimes = -1}
    local loopFun
    if limitTimes and limitTimes > 0 then
        loopFuns[obj].curTimes = 0
    end
    loopFun = function(first)
        local params = loopFuns[obj]
        if not params then
            return
        end
        if first ~= true or noFirstRun ~= true then
            params.func()
            if params.curTimes >= 0 then
                params.curTimes = params.curTimes + 1
                if params.curTimes == limitTimes then
                    Happy.UnRegisterLoopFun(obj)
                    return
                end
            end
        end
        local time = params.gapTime
        if params.getGapTimeFun then
            time = params.getGapTimeFun()
        end
        params.handlerRef = DelayedCall(time, loopFun)
        if log == true then
            print("你妹啊~1", obj, params.handlerRef)
        end
    end
    loopFun(true)
end

function Happy.UnRegisterLoopFun(obj, log)
    local params = loopFuns[obj]
    if params and log == true then
        print("你妹啊~2", obj, params.handlerRef)
    end
    if params and params.handlerRef then
        CancelDelayedCall(params.handlerRef)
    end
    loopFuns[obj] = nil
end

local ceil = math.ceil
local floor = math.floor
local format = string.format
TimeUtil = {}
--- 时间类型：毫秒
TimeUtil.TYPE_MS = "ms"
--- 时间类型：秒
TimeUtil.TYPE_S = "s"
--- 时间类型：分钟
TimeUtil.TYPE_M = "m"
--- 时间类型：小时
TimeUtil.TYPE_H = "h"

--- 转换时间类型
---@param typeFrom string
---@param typeTo string
---@param time number
---@return number
function Happy.TimeConvert(typeFrom, typeTo, time)
    if typeFrom == typeTo then
        return time
    end

    -- 转换成毫秒
    if typeFrom == TimeUtil.TYPE_S then
        time = time * 1000
    elseif typeFrom == TimeUtil.TYPE_M then
        time = time * 60000
    elseif typeFrom == TimeUtil.TYPE_H then
        time = time * 3600000
    end

    -- 返回指定类型
    if typeTo == TimeUtil.TYPE_S then
        return time / 1000
    elseif typeTo == TimeUtil.TYPE_M then
        return time / 60000
    elseif typeTo == TimeUtil.TYPE_H then
        return time / 3600000
    end

    return time
end

--
--- 格式化的时间的默认函数，返回值示例：
--- "7d 01:23:45" / "01:23:45" / "00:01:00" / "01:23" / "00:01"
---@return string
function Happy.FormatTime_Default(d, h, m, s)
    local str
    if d > 0 then
        str = format("%sd ", d)
    else
        str = ""
    end
    if h > 0 or d > 0 then
        str = str .. format("%02d:", h % 24)
    end
    str = str .. format("%02d:%02d", m, s)
    return str
end

--
--- 返回格式化的时间
---@param time number @ 时间值
---@param formatting fun(d, h, m, s):string @ -可选- 格式化函数，默认：StringUtil.FormatTime_Default
---@param timeType string @ -可选- time 的类型，默认：毫秒
---@return string
function Happy.FormatTime(time, formatting, timeType)
    -- 转换为毫秒
    if timeType ~= nil and timeType ~= TimeUtil.TYPE_MS then
        time = Happy.TimeConvert(timeType, TimeUtil.TYPE_MS, time)
    end
    -- 计算各单位的值
    local h = floor(time / 3600000)
    local m = floor(time % 3600000 / 60000)
    local s = ceil(time % 3600000 % 60000 / 1000)
    local d = floor(h / 24)
    if s == 60 then
        s = 0
        m = m + 1
    end
    if m == 60 then
        m = 0
        h = h + 1
    end
    return (formatting or Happy.FormatTime_Default)(d, h % 24, m, s)
end

local WORD_GAP = 100
---播放宋公子喜欢的飞字 想一个一个字飞，则$间隔
function Happy.PlayOverWord(content, callBack, delayHideTime, layerName, gapTime, gap, fixStartX, alignment, setY, fontSize, color)

    gapTime = gapTime or 0.2
    gap = gap or WORD_GAP
    fixStartX = fixStartX or 0
    delayHideTime = delayHideTime or 2
    alignment = alignment or UnityEngine.TextAnchor.MiddleCenter
    setY = setY or 200

    local fixedArr = string.split(content, "$")
    local len = #fixedArr
    local path = "Prefabs/Common/UpgradeOverText.prefab"
    local prefabs = {}
    local startX = -gap * (len-1)/2 + fixStartX

    for i = 1, len do
        DelayedCall((i-1) * gapTime, function ()
            local overT = CreatePrefab(path, layerName or UILayerName.alert)
            local rect = GetComponent.RectTransform(overT)
            rect.anchoredPosition = Vector2.New(startX + gap * (i-1), setY)
            rect.localScale = Vector3.one * 4
            rect:DOScale(Vector3.one * 2, 0.3):SetEase(DOTWEEN_EASE.InQuint)
            local label = GetComponent.Text(overT)
            label.text = fixedArr[i]
            label.alignment = alignment
            label.fontSize = fontSize or 50
            label.color = color or Color.New(245/255,189/255,24/255,255/255)
            GetComponent.DOTweenAnimation(overT):DOPlay()
            table.insert(prefabs, overT)
        end)
    end

    --- delayHideTime = -1 不会自动移除
    if delayHideTime ~= -1 then
        DelayedCall(len * gapTime + delayHideTime, function ()
            for i = 1, #prefabs do
                if isnull(prefabs[i]) ~= true then
                    --PrefabPool.Recycle(prefabs[i], path)
                    GetComponent.Text(prefabs[i]):DOFade(0, 0.3):OnComplete(function ()

                        RecyclePrefab(prefabs[i], path)
                    end)
                end
            end
            if callBack then
                callBack()
            end
        end)
    end
    return prefabs
end

---放烟花
function Happy.PlayFireworks(num, setScale, offsetPos, baseWorldPos, noSound, noRandom)
    num = num or 5
    local oneFireworkFun = function()
        local f = CreatePrefab("Effects/Prefabs/fx_firework_01.prefab",  UILayerName.panel, 2)
        if baseWorldPos then
            f.transform.position = baseWorldPos
        end
        if noRandom ~= true then
            f.transform.localPosition = f.transform.localPosition + Vector3.New(Happy.Random(0,200) - 100,
                    Happy.Random(0,400) - 200, 0)
        end
        if offsetPos then
            f.transform.localPosition = f.transform.localPosition + offsetPos
        end
        f.transform.localScale = Vector3.one * (setScale or 1)
        if noSound ~= true then
            Audio.PlayEffect(AudioConfig.Common.oneFirework)
        end
    end
    for i = 1, num do
        if noRandom ~= true then
            DelayedCall(Happy.Random(0,1), oneFireworkFun)
        else
            oneFireworkFun()
        end
    end
end

---上飞美术数字
function Happy.FlyAddNum(content, fromWorldPos, parent, callBack, flyDur, waitDur)
    local labelGo = CreatePrefab("Prefabs/Common/AddNumFly.prefab", parent or UILayerName.alert)
    local labelRt = GetComponent.RectTransform(labelGo)
    local label = GetComponent.TextMeshProUGUI(labelGo)
    label.text = content
    if fromWorldPos then
        labelRt.anchoredPosition = Happy.WorldToRectPos(fromWorldPos, labelRt.parent, true)
    else
        labelRt.anchoredPosition = Vector2.zero
    end

    local seq = DOTween.Sequence()
    seq:Append(labelRt:DOAnchorPos(Vector2.New(labelRt.anchoredPosition.x, labelRt.anchoredPosition.y + 30), flyDur or 0.2))
    seq:AppendInterval(waitDur or 1)
    seq:Append(label:DOFade(0, 0.3))
    seq:AppendCallback(function()
        RecyclePrefab(labelGo, "Prefabs/Common/AddNumFly.prefab")
        if callBack then
            callBack()
        end
    end)

end

---世界坐标转化为UI层坐标
---@param worldPos Vector3
---@param parent UnityEngine.Transform
---@return Vector3
function Happy.WorldToRectPos(worldPos, parent, bothUICam)
    local uiCamera = GetComponent.Canvas(Game.UICanvas).worldCamera
    if type(parent) == "string" then
        parent = UIMgr.GetLayer(parent)
    end
    local screenP = Vector2.zero
    if bothUICam then
        if GetComponent.Canvas(Game.UICanvas).renderMode == UnityEngine.RenderMode.ScreenSpaceCamera then
            screenP = uiCamera:WorldToScreenPoint(worldPos)
        else
            screenP = worldPos
        end
    elseif Camera.main ~= nil then
        screenP = Camera.main:WorldToScreenPoint(worldPos)
        --print("你妹啊~", screenP.x, screenP.y)
    end
    local hehe, p = RectTransformUtility.ScreenPointToLocalPointInRectangle(parent, screenP, uiCamera, Vector2.zero)

    return p
end

function Happy.Random(min,max)
    return UnityEngine.Random.Range(min or 0,max or 1)
end

---飞奖励
function Happy.RewardFly(iconPath, fromAnchorPos, callBack, toAnchorPos, parent, flyDelay, bornPosRandomRadius)
    iconPath = iconPath or "Textures/UI/Icons/money.png"
    parent = parent or UILayerName.alert
    fromAnchorPos = fromAnchorPos or Vector2.zero
    toAnchorPos = toAnchorPos or Happy.WorldToRectPos(Common.playerInfo.moneyPosTra.position, parent, true)
    flyDelay = flyDelay or 0.5
    bornPosRandomRadius = bornPosRandomRadius or 100

    local item = CreatePrefab("Prefabs/Common/FlyItem.prefab", parent)
    local img = GetComponent.Image(item)
    img.sprite = resMgr:LoadSpriteAtPath(iconPath)
    img:SetNativeSize()
    local rect = GetComponent.RectTransform(item)
    rect.anchoredPosition = fromAnchorPos + Vector2.New(Happy.Random(-bornPosRandomRadius/2, bornPosRandomRadius/2),
            Happy.Random(-bornPosRandomRadius/2, bornPosRandomRadius/2))

    --rect.anchoredPosition = fromAnchorPos
    DelayedCall(flyDelay, function()
        local seq = DOTween.Sequence()
        local dur = Vector2.Distance(rect.anchoredPosition, toAnchorPos)/500
        seq:Append(rect:DOAnchorPos(toAnchorPos, dur))
        seq:Join(rect:DOScale(Vector3.one * 0.4, dur*2/3):SetDelay(dur/3))
        seq:AppendCallback(function()
            if callBack then
                callBack()
            end
        end)
        seq:Append(img:DOFade(0, 0.2))
        seq:AppendCallback(function()
            Happy.SetColorAlpha(img, 1)
            rect.localScale = Vector3.one
            RecyclePrefab(item, "Prefabs/Common/FlyItem.prefab")
        end)
    end)
end

local ALPHA_COLOR = Color.New(1,1,1,0)
----设置Image组件的alpha值
function Happy.SetColorAlpha(component, alpha, color, tweenDur)
    if not component.color then
        return
    end
    local goalColor = color or (component.color * ALPHA_COLOR) + Color.New(0,0,0,alpha)
    if tweenDur then
        component:DOColor(goalColor, tweenDur):SetEase(DOTWEEN_EASE.Linear)
    else
        component.color = goalColor
    end
end

---@param go UnityEngine.GameObject
function Happy.SetSpriteColorAlpha(go, alpha, color, tweenDur, withChildren)
    local parentSprite = GetComponent.SpriteRenderer(go)
    if parentSprite then
        Happy.SetColorAlpha(parentSprite, alpha, color, tweenDur)
    end
    if not withChildren then
        return
    end
    local srList = go:GetComponentsInChildren(typeof(UnityEngine.SpriteRenderer)) ---@type table<number, UnityEngine.SpriteRenderer>
    for i = 1, srList.Length-1 do
        Happy.SetColorAlpha(srList[i], alpha, color, tweenDur)
    end
end


local CountDownInfos = {}
function Happy.CountDownTime(lb, totalTime, callBack, perCallBack, formatStr)
    Happy.ClearCountDownTime(lb)
    local info = {}
    info.totalTime = totalTime
    info.curTime = totalTime
    Happy.RegisterLoopFun(lb, function()
        if info.curTime <= 0 then
            Happy.ClearCountDownTime(lb)
            if callBack then
                callBack()
            end
            return
        end
        info.curTime = info.curTime - 1

        local timeStr = Happy.FormatTime(info.curTime, nil, TimeUtil.TYPE_S)
        if formatStr then
            lb.text = string.format(formatStr, timeStr)
        else
            lb.text = timeStr
        end
        if perCallBack then
            perCallBack(info)
        end
    end, 1)
    CountDownInfos[lb] = info
end

function Happy.ClearCountDownTime(lb)
    local info = CountDownInfos[lb]
    CountDownInfos[lb] = nil
    if not info then
        return
    end
    Happy.UnRegisterLoopFun(lb)
end

local fameMoveHash = {}
---帧移动 固定时间 支持变速
---@param tran UnityEngine.Transform
function Happy.FrameMoveWithFixedTime(tran, endWorldPos, dur, endCall, frameCall, speedFromRate)
    local distance = Vector3.Distance(tran.position, endWorldPos)
    local moveSpeed = distance/dur
    --print("Happy.FrameMoveWithFixedTime", dur, endWorldPos.x, endWorldPos.y, endWorldPos.z)
    local addSpeed = nil
    if speedFromRate then
        addSpeed = moveSpeed * (1+speedFromRate)/dur
        moveSpeed = moveSpeed * (1-speedFromRate)
    end
    local toward = (endWorldPos - tran.position).normalized
    local startTime = Time.time

    --print("你妹啊~", moveSpeed, addSpeed)
    local moveUpdateFun
    moveUpdateFun = function()
        if addSpeed then
            moveSpeed = moveSpeed + addSpeed * Time.deltaTime
        end
        tran.position = tran.position + toward * moveSpeed * Time.deltaTime
        if (Time.time - startTime) >= dur then
            RemoveEventListener(Stage, Event.UPDATE, moveUpdateFun)
            fameMoveHash[tran] = nil
            if endCall then
                endCall()
            end
        elseif frameCall then
            frameCall(moveSpeed)
        end
    end

    AddEventListener(Stage, Event.UPDATE, moveUpdateFun)
    fameMoveHash[tran] = {moveUpdateFun=moveUpdateFun, endCall=endCall, endWorldPos=endWorldPos}
    return moveSpeed
end


---@param tran UnityEngine.Transform
function Happy.KillFramMove(tran, complete)
    if not fameMoveHash[tran] then
        return
    end
    local info = fameMoveHash[tran]
    fameMoveHash[tran] = nil
    RemoveEventListener(Stage, Event.UPDATE, info.moveUpdateFun)
    if complete == true then
        tran.position = info.endWorldPos
        if info.endCall then
            info.endCall()
        end
    end  
end

---改变粒子特效速度
---@param gameObj UnityEngine.GameObject
function Happy.ChangeParticleSystemSpeed(gameObj, speed)
    local ps = GetComponent.ParticleSystem(gameObj)
    ps.main.simulationSpeed = speed
    local list = gameObj:GetComponentsInChildren(typeof(UnityEngine.ParticleSystem), true) ---@type table<number,UnityEngine.ParticleSystem>
    for i = 1, list.Length-1 do
        list[i].main.simulationSpeed = speed
    end
end

function Happy.FlyMsg(content, anchorPos, callBack, parent)
    local item = CreatePrefab("Prefabs/Common/FlyMsg.prefab", parent or Constants.LAYER_ALERT)
    local lb = GetComponent.TextMeshProUGUI(item)
    local rect = GetComponent.RectTransform(item)
    lb.text = content
    Happy.SetColorAlpha(lb, 1)
    rect.anchoredPosition = anchorPos or Vector2.zero
    rect.localScale = Vector3.zero
    local dur = 0.5
    local seq = DOTween.Sequence()
    seq:Append(rect:DOAnchorPosY(rect.anchoredPosition.y + 100, dur):SetEase(DOTWEEN_EASE.InQuint))
    seq:Join(rect:DOScale(Vector3.one, dur):SetEase(DOTWEEN_EASE.InQuint))
    seq:AppendInterval(1.5)
    seq:Append(lb:DOFade(0, 0.3))
    seq:AppendCallback(callBack)
end

local savedCamPos
local savedCamEuler
---开关相机交互组件
function Happy.SetTouchCamEnabled(enbaled, restoreCam)
    GetComponent.MobileTouchCamera(Camera.main.gameObject).enabled = enbaled
    if not restoreCam then
        return
    end
    if enbaled == true then
        if savedCamPos then
            --Camera.main.transform.localPosition = savedCamPos
            Camera.main.transform:DOMove(savedCamPos, 0.5)
        end
        if savedCamEuler then
            --Camera.main.transform.localEulerAngles = savedCamEuler
            Camera.main.transform:DOLocalRotate(savedCamEuler, 0.5, DOTWEEN_ROTATE_MODE.Fast)
        end
    else
        savedCamPos = Camera.main.transform.localPosition
        savedCamEuler = Camera.main.transform.localEulerAngles
    end
end

---处理粒子弹道的随机曲线 curveRange默认12
function Happy.DoWithParticleTrajectory(gameObject, fromWorldPos, toWorldPos, offset, curveRange)

    local rect = GetComponent.RectTransform(gameObject)
    rect.position = fromWorldPos
    rect.forward = toWorldPos - fromWorldPos
    rect.anchoredPosition3D = rect.anchoredPosition3D + (offset or Vector3.New(0,0,-70))

    local Ps = GetComponent.ParticleSystem(gameObject)
    local Force = Ps.velocityOverLifetime
    local PsMain = Ps.main
    local trailPs = GetComponent.ParticleSystem(rect:Find("Trail").gameObject)
    local trailForce = trailPs.velocityOverLifetime
    local trailPsMain = trailPs.main

    ---TEST
    --rect.localScale = Vector3.one * 40
    --local testSpeed = 50
    --PsMain.startSpeedMultiplier = testSpeed
    --trailPsMain.startSpeedMultiplier = testSpeed
    ---TEST

    PsMain.startLifetimeMultiplier = Vector3.Distance(fromWorldPos, toWorldPos)/(PsMain.startSpeedMultiplier * 10 * (rect.localScale.x/100))
    trailPsMain.startLifetimeMultiplier = PsMain.startLifetimeMultiplier
    --print("你妹啊~~", PsMain.startLifetimeMultiplier)
    Force.enabled = true
    trailForce.enabled = true


    local curve = UnityEngine.AnimationCurve.New() ---@type UnityEngine.AnimationCurve
    local randomValue = math.random(0.5,1)
    if math.random() > 0.5 then
        randomValue = randomValue * -1
    end
    curve:AddKey(0, 1 * randomValue)
    curve:AddKey(1, -1 * randomValue)
    --curve:AddKey(1, 1 * randomValue)
    local mmCurve = UnityEngine.ParticleSystem.MinMaxCurve.New(1, curve) ---@type UnityEngine.ParticleSystem.MinMaxCurve
    Force.y = mmCurve
    Force.xMultiplier = 0
    Force.yMultiplier = curveRange or 30
    Force.zMultiplier = 0
    trailForce.y = Force.y
    trailForce.xMultiplier = 0
    trailForce.yMultiplier = Force.yMultiplier
    trailForce.zMultiplier = 0
end

return Happy