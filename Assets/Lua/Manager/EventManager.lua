---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by sunshuo.
--- DateTime: 2023/2/13 10:43
--- 事件管理器

---@class Event.EventListener
---@field type string 事件类型
---@field callback fun() 执行回调
---@field caller any 执行域

---@class Event.Event
---@field type string 事件类型
---@field data any 事件数据

---@class Event.EventManager
local EventManager = {}

local eventMap = {} ---@type table<string, Event.EventListener[]> 事件监听容器
local eventPool = {} ---@type table<number, Event.Event> 事件缓存池

---添加事件监听
---@param target table 事件派发主体
---@param type string 事件类型
---@param callback fun() 事件回调
---@param caller any 事件回调执行域 若没有则不传
function EventManager.AddEventListener(target, type, callback, caller)
    if eventMap[type] == nil then
        eventMap[type] = {}
    end
    local list = eventMap[type]
    if next(list) ~= nil then
        for i = 1, #list do
            local item = list[i] ---@type Event.EventListener
            if item.target == target and item.callback == callback and item.caller == caller then
                print("事件监听重复注册 type:", type, debug.traceback())
                return
            end
        end
    end
    local listener = {}
    listener.target = target
    listener.type = type
    listener.callback = callback
    listener.caller = caller
    table.insert(list, listener)
end

---移除事件监听
---@param target table 事件派发主体
---@param type string 事件类型
---@param callback fun() 事件回调
---@param caller any 事件回调执行域 若没有则不传
function EventManager.RemoveEventListener(target, type, callback, caller)
    local list = eventMap[type]
    if list == nil then
        --LogWarning("RemoveEventListener 事件监听未被注册 type:", type)
        return
    end

    for i = 1, #list do
        local item = list[i] ---@type Event.EventListener
        if item.target == target and item.callback == callback and item.caller == caller then
            table.remove(list, i)
            return
        end
    end
end

---验证事件监听是否存在
---@param target table 事件派发主体
---@param type string 事件类型
---@param callback fun() 事件回调
---@param caller any 事件回调执行域 若没有则不传
---@return boolean
function EventManager.CheckEventListener(target, type, callback, caller)

    local list = eventMap[type]
    if list == nil then
        --LogWarning("RemoveEventListener 事件监听未被注册 type:", type)
        return false
    end

    for i = 1, #list do
        local item = list[i] ---@type Event.EventListener
        if item.target == target and item.callback == callback and item.caller == caller then
            return true
        end
    end
    return false
end

---派发事件
---@param target table 事件派发主体
---@param type string 事件类型
---@param data any 事件数据
---@param isRecycle boolean 是否需要回收事件 默认为true
function EventManager.DispatchEvent(target, type, data, isRecycle)
    local list = eventMap[type]
    if list == nil or #list == 0 then
        --LogWarning("DispatchEvent 事件监听未被注册 type:", type)
        return
    end

    ---获取event
    local event
    if next(eventPool) == nil then
        event = {}
        table.insert(eventPool, event)
    else
        event = table.remove(eventPool)
    end
    event.type = type
    event.data = data
    local item
    for i = 1, #list do
        item = list[i]
        if item == nil then
            print("你妹啊~1", #list, i)
        end
        if EventManager.CheckEventListener(target, type, item.callback, item.caller) == true then
            break
        end
    end
    if item == nil then
        print("你妹啊~2", #list)
    end
    if item.caller then
        item.callback(item.caller, event)
    else
        item.callback(event)
    end

    ---回收event
    if isRecycle == nil then isRecycle = true end --默认为true
    if isRecycle then
        event.type = nil
        event.data = nil
        table.insert(eventPool, event)
    end
end

---打印事件管理相关数据
function EventManager._printEventMap()
    for type,list in pairs(eventMap) do
        print(string.format("正在监听%s事件 监听数量:%s", type, #list))
    end
    print(string.format("事件缓存池数量：%s", #eventPool))
end
return EventManager